#!/usr/bin/env python
# coding: utf-8

# In[374]:


#Variables
R.<x> = ZZ[]
p = 2
n = 1
q = p^n
dim = 3
deg = 2 * dim

#Acquired data from the LMFDB
#Chnage p,n in variables and below in the loads to your new value of q = p^n, up to q = 8

def ConvertLtoWeil(LMFDBlist):
    Weilpolys = []
    for polynomials in LMFDBlist:
        d = polynomials.degree()
        newpolycoeffs = []
        for i in range(d, -1, -1):
            newpolycoeffs.append(polynomials[i])
        Weilpolys.append(R(newpolycoeffs))
    return Weilpolys

#change 2 in the load the below to the new value of q, so that it is load("q-weil_polynomials_dim3.sage")

load("8-weil_polynomials_dim3.sage")

charpolydim3 = ConvertLtoWeil(data_dim3)
charpolydim3prank3 = ConvertLtoWeil(data_dim3_prank3)
charpolydim3prank2 = ConvertLtoWeil(data_dim3_prank2)
charpolydim3prank1 = ConvertLtoWeil(data_dim3_prank1)
charpolydim3prank0 = ConvertLtoWeil(data_dim3_prank0)


# In[352]:


#Build-in function in Sage to generate all q-Weil polynomials of degree deg
L = R.weil_polynomials(deg, q)
print("number of Weil polynomials according to function:", len(L))


# In[353]:


#Generate list of all possible coefficients as in Theorem 9.2

l = []

bounda11 = math.floor(-6 * sqrt(q)) + 1
bounda12 = math.ceil(6 * sqrt(q))

for a1 in range(bounda11, bounda12):
    bounda21 = math.floor(4 * sqrt(q) * abs(a1)) - 9 * q + 1
    bounda22 = math.floor(a1^2 / 3 + 3 * q) + 1
    for a2 in range(bounda21, bounda22):
        bounda31 = math.ceil(-2 * a1^3 / 27 + a1 * a2 / 3 + q * a1 - 2 * (a1^2 - 3 * a2 + 9 * q)^(3/2) / 27)
        bounda32 = math.floor(-2 * a1^3 / 27 + a1 * a2 / 3 + q * a1 + 2 * (a1^2 - 3 * a2 + 9 * q)^(3/2) / 27) + 1
        for a3 in range(bounda31, bounda32):
            bounda33 = -2 * q * a1 - 2 * sqrt(q) * a2 - 2 * q * sqrt(q)
            bounda34 = -2 * q * a1 + 2 * sqrt(q) * a2 + 2 * q * sqrt(q)
            if bounda33 < a3 < bounda34:
                coeff = [q^3, q^2 * a1, q * a2, a3, a2, a1, 1]
                l.append(R(coeff))

print("number of Weil polynomials according to the bounds Theorem 9.2.3:", len(l))


# In[354]:


#Check for differences between lists generated by function and the one generated by bounds
Missing = []

for e in L:
    if e not in l:
        Missing.append(e)
        print(e.factor())

print("number of polynomials missed by the bounds:", len(Missing))

extra = []
for f in l:
    if f not in L:
        extra.append(f)
        print(f.factor())

print("number of extra polynomials found by the bounds", len(extra))

Missingreals = []

for pols in Missing:
    if (pols(sqrt(q)) == 0) or (pols(- sqrt(q)) == 0):
        Missingreals.append(pols)

print("number of the missing polynomials that have a real root:", len(Missingreals))

realsinresult = []

for realtest in l:
    if (realtest(sqrt(q)) == 0) or (realtest(- sqrt(q)) == 0):
        realsinresult.append(realtest)

print("number of weil polynomials with real roots satisfying the bounds:", len(realsinresult))


# In[111]:


#The polynomials missing are exactly the ones with a real root, as in Theorem 9.2.2


# In[368]:


#check which Weil polynomials are characteristic polynomials of simple abelian varieties over F_q

prank0 = []
prank1 = []
prank2 = []
prank3 = []

Rp = Zp(p)
vp = Rp.valuation()
S.<y> = Zp(p, prec = 100, type = 'capped-rel', print_mode = 'series')[]

for polyns in l:
    if polyns.is_irreducible():
        d = polyns.degree()
        if vp(polyns[d - 3]) == 0:
            prank3.append(polyns)
        else:
            rootsof = polyns.roots(Rp)
            rootvalus = []
            if not len(rootsof) == 0:
                for roots in rootsof:
                    rootvalus.append(vp(roots[0]))
            
            coeffsinZp = []
            for co in range(polyns.degree() + 1):
                coeffsinZp.append(polyns[co])
                polynsinZp = S(coeffsinZp)
            factorinZp = polynsinZp.factor()
            factordegs = []
            for fa in factorinZp:
                factordegs.append(fa[0].degree())
            
            if vp(polyns[d - 3]) >= n/2 and vp(polyns[d - 2]) == 0 and n/2 not in rootvalus:
                prank2.append(polyns)
            
            elif vp(polyns[d - 3]) >= n and vp(polyns[d - 2]) >= n/2 and vp(polyns[d - 1]) == 0 and n/2 not in rootvalus:
                prank1.append(polyns)
                
            elif vp(polyns[d - 3]) == n and vp(polyns[d - 2]) >= 2/3 * n and vp(polyns[d - 1]) >= n/3 and len(rootvalus) == 0:
                prank0.append(polyns)
            
            elif vp(polyns[d - 3]) >= 3/2 * n and vp(polyns[d - 2]) >= n and vp(polyns[d - 1]) >= n/2 and len(rootvalus) == 0 and 3 not in factordegs:
                prank0.append(polyns)            
            
    elif n % 3 == 0 and len(polyns.factor()) == 1:
        if polyns.factor()[0][1] == 3:
            if abs(polyns.factor()[0][0][1]) < 2 * sqrt(q) and polyns.factor()[0][0][1] % q^(1/3) == 0 and not polyns.factor()[0][0][1] / q^(1/3) % p == 0:
                prank0.append(polyns)

total = prank0 + prank1 + prank2 + prank3

#beneath is the comparison with LMFDB


# In[369]:


Missing3 = []

for m in charpolydim3prank3:
    if m not in prank3:
        Missing3.append(m)

extra3 = []

for M in prank3:
    if M not in charpolydim3prank3:
        extra3.append(M)

print("number of characteristic polynomials p-rank 3 in LMFDB:", len(data_dim3_prank3))
print("number of characteristic polynomials p-rank 3 according to code:", len(prank3))
print("characteristic polynomials in LMFDB but not in code:", Missing3)
print("characteristic polynomials in code, but not in LMFDB:", extra3)


# In[370]:


Missing2 = []

for m in charpolydim3prank2:
    if m not in prank2:
        Missing2.append(m)

extra2 = []

for M in prank2:
    if M not in charpolydim3prank2:
        extra2.append(M)        
        
print("number of characteristic polynomials p-rank 2 in LMFDB:", len(data_dim3_prank2))
print("number of characteristic polynomials p-rank 2 according to code:", len(prank2))
print("characteristic polynomials in LMFDB but not in code:", Missing2)
print("characteristic polynomials in code, but not in LMFDB:", extra2)


# In[371]:


Missing1 = []

for m in charpolydim3prank1:
    if m not in prank1:
        Missing1.append(m)

extra1 = []

for M in prank1:
    if M not in charpolydim3prank1:
        extra1.append(M)  
        
print("number of characteristic polynomials p-rank 1 in LMFDB:", len(data_dim3_prank1))
print("number of characteristic polynomials p-rank 1 according to code:", len(prank1))
print("characteristic polynomials in LMFDB but not in code:", Missing1)
print("characteristic polynomials in code, but not in LMFDB:", extra1)


# In[372]:


Missing0 = []

for m in charpolydim3prank0:
    if m not in prank0:
        Missing0.append(m)

extra0 = []

for M in prank0:
    if M not in charpolydim3prank0:
        extra0.append(M)  
        
print("number of characteristic polynomials p-rank 0 in LMFDB:", len(data_dim3_prank0))
print("number of characteristic polynomials p-rank 0 according to code:", len(prank0))
print("characteristic polynomials in LMFDB but not in code:", Missing0)
print("characteristic polynomials in code, but not in LMFDB:", extra0)


# In[375]:


Missingtotal = Missing0 + Missing1 + Missing2 + Missing3
extratotal = extra0 + extra1 + extra2 + extra3

print("total number of characteristic polynomials in LMFDB:", len(data_dim3))
print("total number of characteristic polynomial according to code:", len(total))
print("characteristic polynomials in LMFDB but not in code:", Missingtotal)
print("characteristic polynomials in code but not in LMFDB:", extratotal)


# In[ ]:




