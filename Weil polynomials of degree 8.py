#!/usr/bin/env python
# coding: utf-8

# In[203]:


#Variables
R.<x> = ZZ[]
C = ComplexField(10000)
p = 2
n = 1
q = p^n
dim = 4
deg = 2 * dim

#Acquired data from the LMFDB
#Chnage p,n in variables and below in the loads to your new value of q = p^n, up to q = 5

def ConvertLtoWeil(LMFDBlist):
    Weilpolys = []
    for polynomials in LMFDBlist:
        d = polynomials.degree()
        newpolycoeffs = []
        for i in range(d, -1, -1):
            newpolycoeffs.append(polynomials[i])
        Weilpolys.append(R(newpolycoeffs))
    return Weilpolys

#change 2 in the load the below to the new value of q, so that it is load("q-weil_polynomials_dim4.sage")

load("2-weil_polynomials_dim4.sage")

charpolydim4 = ConvertLtoWeil(data_dim4)
charpolydim4prank4 = ConvertLtoWeil(data_dim4_prank4)
charpolydim4prank3 = ConvertLtoWeil(data_dim4_prank3)
charpolydim4prank2 = ConvertLtoWeil(data_dim4_prank2)
charpolydim4prank1 = ConvertLtoWeil(data_dim4_prank1)
charpolydim4prank0 = ConvertLtoWeil(data_dim4_prank0)


# In[175]:


#Build-in function in Sage to generate all q-Weil polynomials of degree deg
L = R.weil_polynomials(deg, q)
print("number of Weil polynomials according to function:", len(L))


# In[176]:


#Generate list of all possible coefficients as in Theorem 10.2.3

l = []

bounda1lower = math.floor(- 8 * sqrt(q)) + 1
bounda1higher = math.ceil(8 * sqrt(q))

for a1 in range(bounda1lower, bounda1higher):
    u2part1 = 3/8 * a1^2 + 4 * q
    
    bounda2lower = math.floor(6 * sqrt(q) * abs(a1) - 20 * q) + 1
    bounda2higher = math.floor(u2part1) + 1
    
    for a2 in range(bounda2lower, bounda2higher):
        u2 = (-u2part1 + a2)/2
        
        u3part1 = a1 * a2 / 2 - a1^3 / 8 + a1 * q
        bounda3firstvar = (-4/3 * u2)^(3/2)
        
        bounda3lower1 = math.ceil(u3part1 - bounda3firstvar)
        bounda3higher1 = math.floor(u3part1 + bounda3firstvar) + 1
        
        bounda3secondabs = 4 * sqrt(q) * a2 + 16 * q * sqrt(q)
        bounda3secondvar = - 9 * q * a1
        
        bounda3lower2 = math.floor(- bounda3secondabs + bounda3secondvar) + 1
        bounda3higher2 = math.ceil(bounda3secondabs + bounda3secondvar)
        
        bounda3lower = max(bounda3lower1, bounda3lower2)
        bounda3higher = min(bounda3higher1, bounda3higher2)
        
        for a3 in range(bounda3lower, bounda3higher):
            u3 = (u3part1 - a3) / 4
            
            bounda4abs = 3/256 * a1^4 - a1^2 * a2 / 16 - a1^2 * q / 2 + a1 * a3 / 4 + 2 * a2 * q - 2 * q^2 + 2/3 * u2^2
            
            etareal = - u2^6 / 27 - 5 * u2^3 * u3^2 + 27/2 * u3^4
            etaimaginary = 27/2 * u3 * (- u3^2 - 4/27 * u2^3)^(3/2)
            
            base = C(etareal, etaimaginary)
            eta = base.nth_root(3)
            eta2 = eta * E(3)
            eta3 = eta * E(3)^2
            
            root1 = 2 * real_part(eta)
            root2 = 2 * real_part(eta2)
            root3 = 2 * real_part(eta3)
            
            bounda4lower1 = math.ceil(bounda4abs + min([root1, root2, root3]))
            bounda4higher = math.floor(bounda4abs + median([root1, root2, root3])) + 1
            
            bounda4lower2 = math.floor(2 * sqrt(q) * abs(a1 * q + a3) - 2 * q * a2 - 2 * q^2) + 1
            
            bounda4lower = max(bounda4lower1, bounda4lower2)
            
            for a4 in range(bounda4lower, bounda4higher):
                l.append(R([q^4, a1 * q^3, a2 * q^2, a3 * q, a4, a3, a2, a1, 1]))
                
print(len(l))


# In[177]:


#Check for differences between lists generated by function and the one generated by bounds
Missing = []

for e in L:
    if e not in l:
        Missing.append(e)
        print(e.factor())

print("number of polynomials missed by the bounds:", len(Missing))

extra = []
for f in l:
    if f not in L:
        extra.append(f)
        print(f.factor())

print("number of extra polynomials found by the bounds", len(extra))

Missingreals = []

for pols in Missing:
    if (pols(sqrt(q)) == 0) or (pols(- sqrt(q)) == 0):
        Missingreals.append(pols)

print("number of the missing polynomials that have a real root:", len(Missingreals))

realsinresult = []

for realtest in l:
    if (realtest(sqrt(q)) == 0) or (realtest(- sqrt(q)) == 0):
        realsinresult.append(realtest)

print("number of weil polynomials with real roots satisfying the bounds:", len(realsinresult))


# In[10]:


#The polynomials above are exactly the ones described in "the other case" in Haloui's theorem 1.1


# In[197]:


#check which Weil polynomials are characteristic polynomials of simple abelian varieties over F_q

prank0 = []
prank1 = []
prank2 = []
prank3 = []
prank4 = []

Rp = Zp(p)
vp = Rp.valuation()
S.<y> = Zp(p, prec = 10000, type = 'capped-rel', print_mode = 'series')[]

for polyns in l:
    if polyns.is_irreducible():
        d = polyns.degree()
        vpa4 = vp(polyns[d - 4])
        vpa3 = vp(polyns[d - 3])
        vpa2 = vp(polyns[d - 2])
        vpa1 = vp(polyns[d - 1])
        
        if vpa4 == 0:
            prank4.append(polyns)
        else:
            rootsof = polyns.roots(Rp)
            rootvalus = []
            if not len(rootsof) == 0:
                for roots in rootsof:
                    rootvalus.append(vp(roots[0]))
            
            coeffsinZp = []
            for co in range(polyns.degree() + 1):
                coeffsinZp.append(polyns[co])
                polynsinZp = S(coeffsinZp)
            
            factorinZp = polynsinZp.factor()
            factordegs = []
            for fa in factorinZp:
                factordegs.append(fa[0].degree())
            
            if vpa4 >= n/2 and vpa3 == 0 and n/2 not in rootvalus:
                prank3.append(polyns)
            
            elif vpa4 >= n and vpa3 >= n/2 and vpa2 == 0 and n/2 not in rootvalus:
                prank2.append(polyns)
            
            elif vpa4 == n and vpa3 >= 2/3 * n and vpa2 >= n/3 and vpa1 == 0 and (2/3 * n not in rootvalus) and (n/3 not in rootvalus):
                prank1.append(polyns)
            
            elif vpa4 >= 3/2 * n and vpa3 >= n and vpa2 >= n/2 and vpa1 == 0 and (n/2 not in rootvalus) and 3 not in factordegs:
                prank1.append(polyns)            

            elif vpa4 == n and vpa3 >= 3/4 * n and vpa2 >= n/2 and vpa1 >= n/4 and len(rootvalus) == 0 and 2 not in factordegs:
                prank0.append(polyns) 

            elif vpa4 >= 3/2 * n and vpa3 == n and vpa2 >= 2/3 *n and vpa1 >= n/3 and len(rootvalus) == 0:
                prank0.append(polyns) 
            
            elif vpa4 >= 2 * n and vpa3 >= 3/2 * n and vpa2 >= n and vpa1 >= n/2 and len(rootvalus) == 0 and 3 not in factordegs:
                prank0.append(polyns) 
                

    elif len(polyns.factor()) == 1:
        if n % 3 == 0 and polyns.factor()[0][1] == 3:
            if abs(polyns.factor()[0][0][1]) < 2 * sqrt(q) and polyns.factor()[0][0][1] % q^(1/3) == 0 and not polyns.factor()[0][0][1] / q^(1/3) % p == 0:
                prank0.append(polyns)
        
        elif polyns.factor()[0][1] == 2:
            m = polyns.factor()[0][0]
            d = m.degree()
            b2 = m[d - 2]
            b1 = m[d - 1]
            
            vpb2 = vp(b2)
            vpb1 = vp(b1)
            
            rootsof = m.roots(Rp)
            rootvalus = []
            if not len(rootsof) == 0:
                for roots in rootsof:
                    rootvalus.append(vp(roots[0]))
            
            coeffsinZp = []
            for co in range(m.degree() + 1):
                coeffsinZp.append(m[co])
                polynsinZp = S(coeffsinZp)
            
            factorinZp = polynsinZp.factor()
            factordegs = []
            for fa in factorinZp:
                factordegs.append(fa[0].degree())
            
            if vpb2 >= n/2 and vpb1 == 0 and Rp((b2 + 2 * q)^2 - 4 * q * b1).is_square():
                prank2.append(polyns)
            
            elif vpb2 == n/2 and vpb1 >= n/4 and len(rootvalus) == 0:
                prank0.append(polyns)
                
            elif vpb2 >= n and vpb1 >= n/2 and not len(rootvalus) == 0:
                prank0.append(polyns)

total = prank0 + prank1 + prank2 + prank3 + prank4

#beneath is the comparison with LMFDB


# In[204]:


Missing4 = []

for m in charpolydim4prank4:
    if m not in prank4:
        Missing4.append(m)

extra4 = []

for M in prank4:
    if M not in charpolydim4prank4:
        extra4.append(M)

print("number of characteristic polynomials p-rank 4 in LMFDB:", len(data_dim4_prank4))
print("number of characteristic polynomials p-rank 4 according to code:", len(prank4))
print("characteristic polynomials in LMFDB but not in code:", Missing4)
print("characteristic polynomials in code, but not in LMFDB:", extra4)


# In[205]:


Missing3 = []

for m in charpolydim4prank3:
    if m not in prank3:
        Missing3.append(m)

extra3 = []

for M in prank3:
    if M not in charpolydim4prank3:
        extra3.append(M)

print("number of characteristic polynomials p-rank 3 in LMFDB:", len(data_dim4_prank3))
print("number of characteristic polynomials p-rank 3 according to code:", len(prank3))
print("characteristic polynomials in LMFDB but not in code:", Missing3)
print("characteristic polynomials in code, but not in LMFDB:", extra3)


# In[206]:


Missing2 = []

for m in charpolydim4prank2:
    if m not in prank2:
        Missing2.append(m)

extra2 = []

for M in prank2:
    if M not in charpolydim4prank2:
        extra2.append(M)

print("number of characteristic polynomials p-rank 3 in LMFDB:", len(data_dim4_prank2))
print("number of characteristic polynomials p-rank 3 according to code:", len(prank2))
print("characteristic polynomials in LMFDB but not in code:", Missing2)
print("characteristic polynomials in code, but not in LMFDB:", extra2)


# In[207]:


Missing1 = []

for m in charpolydim4prank1:
    if m not in prank1:
        Missing1.append(m)

extra1 = []

for M in prank1:
    if M not in charpolydim4prank1:
        extra1.append(M)

print("number of characteristic polynomials p-rank 3 in LMFDB:", len(data_dim4_prank1))
print("number of characteristic polynomials p-rank 3 according to code:", len(prank1))
print("characteristic polynomials in LMFDB but not in code:", Missing1)
print("characteristic polynomials in code, but not in LMFDB:", extra1)


# In[208]:


Missing0 = []

for m in charpolydim4prank0:
    if m not in prank0:
        Missing0.append(m)

extra0 = []

for M in prank0:
    if M not in charpolydim4prank0:
        extra0.append(M)

print("number of characteristic polynomials p-rank 3 in LMFDB:", len(data_dim4_prank0))
print("number of characteristic polynomials p-rank 3 according to code:", len(prank0))
print("characteristic polynomials in LMFDB but not in code:", Missing0)
print("characteristic polynomials in code, but not in LMFDB:", extra0)


# In[ ]:




